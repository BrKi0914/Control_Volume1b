"""Utility functions to run the Control Volume Heat c1b model"""
import numpy as np
import matplotlib.pyplot as plt

def H2T(H, Cpave):
    
    """Converts enthalpy to temperature.
        
    The specific heat is allowed to be temperature dependent.
        
    Parameters
    ----------
    H : scalar
    Enthalpy.
    Cpave : ndarray
    Specific heat.
    Returns
    -------
    result : ndarray
    Temperature.
        
    Example
    --------
    >>> from c1b_util1 import H2T
    >>> H = 55.0
    >>> Cpave = np.array([0.5,1.0 ,0.75,0.8])
    >>> H2T(H,Cpave)
        
    """
    
    Tref = 0  		# The reference temperature is assumed to be 0 C.
    temp = Tref + H/Cpave
    
    return temp

def T2H(temp, Cpave): 
      
    """Converts temperature to enthalpy. 
    
    The specific heat is allowed to be temperature dependent
   
    Parameters
    ----------
    T : scalar
    Temperature.
    Cpave : ndarrayDE_coefs_1a.ipynb
    Specific heat.
    Returns
    -------
    result : ndarray
    Enthalpy.
    
    Example
    ------- 
    >>> from c1b_util1 import T2H   
    >>> T = 25.0 
    >>> Cpave = np.array([0.5, 0.8,0.9,1.0])
    >>> T2H(T,Cpave) 
   
    """ 
     
    Tref = 0            # The reference temperature is assumed to be 0 C.
    H = Cpave * (temp - Tref)  
 
    return H 
 
def K_eff(m,K,varep):
    
     """Find the effective conductivity at the interfaces.
     
     K      conductivity at the grid pts
     varep  fractional distance
     
     Parameters
     ----------
     m : scalar
     K : ndarray
     varep : ndarray
     Returns
     -------
     result : ndarray
     Effective conductivity.
     
     Example
     -------
     >>> from c1b_util1 import K_eff
     >>> n = 4
     >>> a = np.ones(n)
     >>> b = np.zeros(n) + 2 
     >>> K_eff(n,a,b)
     
     """
      
     Ke = np.zeros(m)
    
     for k in range(1,m):

     # Ke[k-1] = 1/(1-float(varep[k])/float(K[k-1]) + float(varep[k])/float(K[k]))
     
     # Another formula that may improve the Ke[k-1] 
        
         Ke[k-1] = 1/(1-varep[k]/K[k-1] + varep[k]/K[k])
    
     return Ke
     
def extract_str(s):
    
     """Extract a string from a line that contains a comment.
     
     Eg.    e3_layer    Lname
     
     Parameters
     ----------
     s : string
     Returns
     -------
     result : string
     
     Example
     -------
     >>> from c1b_util1 import extract_str
     >>> extract_str(str1)
     
     """
     str1 = "e3_layer % Lname" 
     k = str1.find('%')
     s2 = (str1[0:k])
     
     return s2.strip()
     
def extract_num(s):
     
     """Extract a number from a line that contains a comment
     
     Eg.    -10.5    surface temperature
     
     Parameters
     ----------
     s : string
     Returns
     -------
     result : float
     
     Example
     -------
     >>> from c1b_util1 import extract_num
     >>> extract_num(str1)
     
     """
     str1 = "-10.5   % surface temperature"
     k = str1.find("%")
     x = float(str1[0:k])
      
     return x
     
def DE_coefs_1a(dtf,dt1mf,Dzrho,Kedz,cpave,QS,Jb,Jbn):
    
     """Find DE coefs for CV code cv1a.m
     
     diffusion:               yes
     advection:               no
     composite materials:     yes
     melting:                 no
     source term:             yes
     
     Note:  for unconditional stability, aPp should be greater than 0.
     This can fail if step dt is too large.
     
     Parameters
     ----------
     dtf : integer
     
     dt1mf : integer
     
     Dzrho : ndarray
     
     Kedz : ndarray
     
     cpave : ndarray
     
     QS : ndarray
     
     Jb : integer
     
     Jbn : integer
     
     Returns
     -------
     Result : ndarray
     
     Example
     -------
     >>> from c1b_util1 import DE_coefs_1a
     >>> dtf = 1
     >>> dt1mf = 3
     >>> Dzrho = np.zeros(N) + 4
     >>> Kedz = np.zeros(N) + 3
     >>> cpave = np.zeros(N) + 5
     >>> QS = np.zeros(N) + 6
     >>> Jb = 7
     >>> Jbn = 8
     >>> DE_coefs_1a(dtf,dt1mf,Dzrho,Kedz,cpave,QS,Jb,Jbn)
     
     """
     N = 4
     aU = np.zeros(N)
     aP = np.zeros(N)
     aD = np.zeros(N)
     aUp = np.zeros(N)
     aPp = np.zeros(N)
     aDp = np.zeros(N)
     b = np.zeros(N)
     
     for k in range(1,N-1):
         
         aU[k] = dtf * Kedz[k] / cpave[k-1]
         aUp[k] = dt1mf * Kedz[k] / cpave[k-1]
         aD[k] = dtf * Kedz[k+1] / cpave[k+1]
         aDp[k] = dt1mf * Kedz[k+1] / cpave[k+1]
         aP[k] = Dzrho[k] + dtf * (Kedz[k]/cpave[k] + Kedz[k+1]/cpave[k])
         aPp[k] = Dzrho[k] - dt1mf * (Kedz[k]/cpave[k] + Kedz[k+1]/cpave[k])
         b[k] = QS[k]
         
     k = N - 1
     aU[k] = dtf * Kedz[k] / cpave[k-1]
     aUp[k] = dt1mf * Kedz[k] / cpave[k-1]
     aD[k] = 0
     aDp[k] = 0
     aP[k] = Dzrho[k] + dtf * Kedz[k]/cpave[k]
     aPp[k] = Dzrho[k] - dt1mf * Kedz[k]/cpave[k]
     b[k] = QS[k] - dtf*Jb - dt1mf*Jbn
     
     return aU,aP,aD,aUp,aPp,aDp,b
     
def DE_coefs_1b(dtf,dt1mf,DzC,Kedz,QS,qb,qbn):
    
     """Find DE coefs for CV code cv1b.m
     
     diffusion:            yes
     advection:            no
     composite materials:  yes
     melting:              yes
     source term:          yes
     
     Note:  for unconditional stability, aPp should be greater than 0.
     This will fail if time step dt is too large.
     
     Parameters
     ----------
     dtf : integer
     
     dt1mf : integer
     
     Dzc : ndarray
     
     Kedz : ndarray
     
     QS : ndarray
     
     qb : integer
     
     qbn : integer
     Returns
     -------
     result : ndarray
     
     Example
     -------
     >>> from c1b_util1 import DE_coefs_1b
     >>> dtf = 3
     >>> dt1mf = 2
     >>> DzC = np.zeros(N) + 4
     >>> Kedz = np.zeros(N) 
     >>> QS = np.zeros(N) + 1
     >>> qb = 5
     >>> qbn = 8
     >>> DE_coefs_1b(dtf,dt1mf,DzC,Kedz,QS,qb,qbn)
     
     """
     
     N = 4
     aU = np.zeros(N)
     aP = np.zeros(N)
     aD = np.zeros(N)
     aUp = np.zeros(N)
     aPp = np.zeros(N)
     aDp = np.zeros(N)
     b = np.zeros(N)
     
     for k in range(1,N-1):
         aU[k] = dtf * Kedz[k]
         aUp[k] = dt1mf * Kedz[k]
         aD[k] = dtf * Kedz[k]
         aDp[k] = dt1mf * Kedz[k+1]
         aP[k] = DzC[k] + dtf * (Kedz[k] + Kedz[k+1])
         aPp[k] = DzC[k] - dt1mf * (Kedz[k] + Kedz[k+1])
         b[k] = QS[k] 
         k = N-1
     
     aU[k] = dtf * Kedz[k]
     aUp[k] = dt1mf * Kedz[k]
     aD[k] = 0
     aDp[k] = 0
     aP[k] = DzC[k] + dtf * Kedz[k]
     aPp[k] = DzC[k] - dt1mf * Kedz[k]
     b[k] = QS[k] - dtf*qb - dt1mf*qbn
     
     return aU,aP,aD,aUp,aPp,aDp,b
    
def TDMA(aU,aP,aD,aUp,aPp,aDp,b,Hn,Hs):
     
     """TDMA algorithm in the z-direction for eithr enthalpy-based or 
     temperature-based CV models.
     
     Sweep from top to bottom.
     
     Parameters:
     -----------
     aU : ndarray
     
     aP : ndarray
     
     aD : ndarray
     
     aUp : ndarray
     
     aPp : ndarray
     
     aDp : ndarray
     
     b : ndarray
     
     Hn : ndarray
     
     Hs : integer
     
     Returns
     -------
     result : ndarray
     
     Example
     -------
     >>> from c1b_util1 import TDMA
     >>> n = 4
     >>> aU = np.ones(n) + 2
     >>> aP = np.ones(n) 
     >>> aD = np.ones(n) + 1
     >>> aUp = np.ones(n) + 3 
     >>> aPp = np.ones(n) + 4 
     >>> aDp = np.ones(n) + 5 
     >>> b = np.ones(n) + 6 
     >>> Hn = np.ones(n) + 7 
     >>> Hs = 1
     >>> TDMA(aU,aP,aD,aUp,aPp,aDp,b,Hn,Hs)
     
     """
     
     N = 4
     E = np.zeros(N)
     P = np.zeros(N)
     Q = np.zeros(N)
     H = np.zeros(N)
     
     for k in range(1,N-1):
         E[k] = aUp[k] * Hn[k-1] + aPp[k] * Hn[k] + aDp[k] * Hn[k+1] + b[k] 
     E[N-1] = aUp[N-1] * Hn[N-2] + aPp[N-1] * Hn[N-1] + b[N-1]
     
     H[0] = Hs
     
     P[N-1] = aU[N-1]/aP[N-1]
     Q[N-1] = E[N-1]/aP[N-1]
     
     for k in range(N-2,0,-1):
         fac = aP[k] - aD[k] * P[k+1]
         P[k] = aU[k]/fac
         Q[k] = (E[k] + aD[k] * Q[k+1])/fac
         
     for k in range(1,N):
         H[k] = P[k] * H[k-1] + Q[k]
         
     return H
     
def init_T(N,t,spaceP,TpropP,QS,sourceP,bcP,testP,init_opt):
     
     """Setup initial temperature field using the following methods,
     
     init_opt = 1 input initial field from a file
     init_opt = 2 calcuate field assuming steady-state conditions
     init_opt = 3 use analytic expressions
     
     Parameters
     ----------
     N : integer
     
     t : integer
     
     spaceP : list
     
     TpropP : list
     
     QS : ndarray
     
     sourceP : ndarray
     
     bcP : ndarray
     
     testP : list
     
     init_opt : integer
     Returns
     -------
     Result : ndarray 
     
     Example
     -------
     >>> from c1b_util1 import init_T
     >>> N = 4
     >>> t = 5
     >>> spaceP = [1,range(0,N),np.zeros(N) + 0.2,np.zeros(N) + 0.3]
     >>> sourceP = np.zeros(N)+4
     >>> TpropP = [np.zeros(N)+0.1,2.4,1e6,np.zeros(N)+0.5]
     >>> QS = np.zeros(N) + 3
     >>> bcP = np.zeros(N) + 5
     >>> testP = ['e2',0,0.1,2]
     >>> init_opt = 3
     >>> z = spaceP[1]
     >>> init_T(N,t,spaceP,TpropP,QS,sourceP,bcP,testP,init_opt)
     
     """
     K = TpropP[0]
     rho = TpropP[1]
     cp = TpropP[2]
     diffu = K/(rho*cp)
     secyr = 86400*365
     Dz = spaceP[2]
     Ke = TpropP[3]
     dz = spaceP[3]
     Ts = bcP[0]
     Jb = bcP[0]
     qb = -Jb
     T = np.zeros(N)
     K = TpropP[0]
     zn = range(1,N+1)
     import math
    
     if init_opt == 1:
         print ('')
         a1 = []
         a2 = []
         Tzname = ('Type name of initial temperature profile: ','s')
         fid = open('Tzname.txt','r')
         header1 = fid.readline()
         header2 = fid.readline()
         header3 = fid.readline()
         par = fid.readline()
         k = par.find (' ')
         s1 = (par[0:k].strip())
         s2 = (par[k:len(par)].strip())
         wk=[float(s1),float(s2)]
         count = len(wk)
         fid.close()
         wk = np.conjugate(wk)
         zA = wk[:1]
         TzA = wk[1:]
         
     if init_opt == 2:
         
         J = np.zeros(N+1)
         J[4] = -qb
         for i in range(N-1,-1,-1):
             J[i] = J[i+1] - QS[i]
             
         Kedz = Ke[:]/dz
         T[0] = Ts
         for i in range(1,N):
             T[i] = T[i-1] - J[i]/Kedz[i]
     if init_opt == 3:
        
         experim = testP[0]
         T0 = testP[1]
         dT = testP[2]
         period = testP[3]
         
         if experim == 'e1':
             
             T = T0 + zn * (qb/K[:])
             
         elif experim == 'e2':
             
             S0 = sourceP[0]
             h = sourceP[1]
             
             T = T0 + (S0/K[:]) * (h**2) * (1- (np.exp(np.negative(zn[:])/h)))
             
         elif experim == 'e3':
             Tf = np.zeros(N+1)
             Tf[0] = T0
             for k in range(0,N):
                 Tf[k+1] = Tf[k] + Dz[k] * qb/K[k]
             T[0] - Tf[0]
             for k in range(1,N):
                 T[k] = 0.5*(Tf[k] + Tf[k+1])
                 
         elif experim == 'e4':
             
             K0 = 2
             dKdT = -0.0140
             
             T[0] = T0
             for k in range(1,N):
                 C = -(2*K0*T[k-1] + (dKdT*T[k-1]**2) + 2*qb*dz[k])
                 T[k] = (-K0 + math.sqrt(K0**2 - dKdT*C))/dKdT
                
         elif experim == 'e5':
            
            T = T0 + zn[:] * (qb/K[:])
            
            
         elif experim == 'e6':
             
             lambda_ = secyr*period
             w = 2*math.pi/lambda_
             k = np.sqrt(math.pi/(lambda_*diffu[:]))
             T = T0 + dT * np.cos(k[:]*zn[:] - w*t + math.pi/2) * (np.exp(np.negative(k)*zn[:]))
             
         elif experim == 'e7':
             
             T = T0 + zn[:] * (qb/K[:])
        
         else:
             print ('')
             print ('init_T: sorry no analytic soln available when itest = 0')
    
     return T  
             
def Z_grid(zfuL,zfdL,typL,nL,pos):
     
     """Routine setups up the Contour Volume Space Grid (z-direction).
     
     Parameters
     ----------
     zfuL : ndarray
     
     zfdL : ndarray
     
     typL : ndarray
     
     nL : ndarray
      
     pos : integer
     Returns
     -------
     Result : ndarray
     
     
     Example
     -------
     >>> from c1b_util1 import Z_grid 
     >>> n = 4
     >>> j = 1
     >>> pos = 1
     >>> nL = np.ones(n) + 1.5
     >>> typL = np.ones(n) + 2
     >>> nlayers = len(typL)
     >>> zfdL = np.ones(n) + 1
     >>> zfuL = np.ones(n)
     >>> def Z_grid(zfuL, zfdL, typL, nL, pos)
     
     """
     typ = np.zeros(10)
     n = 4 
     nlayers = len(typL)

     nL = np.ones(n) + 1.5  
    
     if nL[0]%1 != 0.5:
         print(' ') 
         print('Error: Z_grid.m') 
         print('Upper physical layer needs to include a 1/2-CV.  Thus, nL(1) ') 
         print('should be a number like 1.5, 2.5, 4.5, etc.') 
    
     j = 1 
     Dz = (zfdL[0] - zfuL[0]) / nL[0]                 
     zf = [zfuL[0], zfuL[0] + 0.5*Dz]                 
     zfx = np.arange(zf[1] + Dz, zfdL[0]+Dz, Dz)      
     zf = zf = np.concatenate((zf, zfx))           
     n = len(zf) - 1                                                                                      
     for i in range(1,n): 
         typ[i] = typL[0] 
     nn = n 
     for j in range(1, nlayers): 
         Dz = (zfdL[j] - zfuL[j]) / nL[j]             
         zfx = np.arange(zfuL[j] + Dz, zfdL[j], Dz) 
         zf = np.concatenate((zf,zfx)) 
         n = len(zf) - 1                            
         for i in (nn, n-1): 
             typ[i] = typL[j] 
         nn = n 
     N = len(zf) - 1                                                                                          
     typ[0] = typ[1]                                  
     del Dz  
    
     zfu = np.zeros(N) 
     zfd = np.zeros(N) 
     for i in range(0,N): 
         zfu[i] = zf[i] 
         zfd[i] = zf[i+1]
        
     z = np.zeros(N+1) 
     for i in range(1,N): 
         z[i] = 0.5*(zfu[i] + zfd[i]) 
     z[0] = zf[0] 
     z[N] = zf[N]
    
     Dz = np.zeros(N) 
     for i in range(0,N): 
         Dz[i] = zfd[i] - zfu[i]
                
     dz = np.zeros(N) 
     for i in range(1,N): 
         dz[i] = z[i] - z[i-1] 
     dz[0] = 10E-10    
    
     varep = np.zeros(N) 
     for i in range(1,N): 
         varep[i] = (z[i] - zf[i])/ dz[i]                
    
     return zf,z,Dz,dz,varep,typ,N
     
     Dz = (zfdL[0] - zfuL[0]) / nL[0]
     zf = [zfuL[0], zfuL[0] + 0.5*Dz]
     zfx = np.arange(zf[1] + Dz, zfdL[0]+Dz, Dz)
     zf = np.concatenate((zf, zfx))
     n = len(zf) - 1
     for i in range(1,n):
         typ[i] = typL[0]
     nn = n
     for j in range(1,nlayers):
         Dz = (zfdL[j] - zfuL[j]) / nL[j]
         zfx = np.arange(zfuL[j] + Dz, zfdL[j], Dz)
         zf = np.concatenate((zf,zfx))
         n = len(zf) - 1
         for i in (nn, n-1):
             typ[i] = typL[j]
         nn = n
     N = len(zf) - 1
     typ[0] = typ[1]
     del Dz
     zfu = np.zeros(N)
     zfd = np.zeros(N)
     for i in range(0,N):
         zfu[i] = zf[i]
         zfd[i] = zf[i+1]
     z = np.zeros(N+1)
     for i in range(1,N):
         z[i] = 0.5*(zfu[i] + zfd[i])
     z[0] = zf[0]
     z[N] = zf[N]
     Dz = np.zeros(N)
     for i in range(0,N):
         Dz[i] = zfd[i] - zfu[i]
     dz = np.zeros(N)
     for i in range(1,N):
         dz[i] = z[i] - z[i-1]
     dz[0] = 10E-10
     varep = np.zeros(N)
     for i in range(1,N):
         varep[i] = (z[i] - zf[i])/ dz[i]

     junkx = float('NaN') *np.ones(zfuL.shape)
     plt.plot(junkx,zfuL)
     plt.plot(junkx,zfdL)
     v = plt.axis([0,1,0,2])
     plt.gca().invert_yaxis()
     junk2 = 0.5*(v[1] - v[0] * np.ones(z.shape))
     plt.ylabel('Depth (m)')
     plt.title('Physical Layers (blue), CV interfaces (red), CV grid pts (black)')
# show physical layers
     for j in range(0,nlayers):
         plt.axhline(zfuL[j],0,1)
     plt.axhline(zfdL[j],0,1)
# show CV interfaces
     for i in range(0,N+1):
         plt.axhline(zf[i],0,1,color='r')
# show CV grid pts
     for i in range(0,N+1):
         plt.plot(junk2,z,'o',markerfacecolor = 'k')
     plt.axis([0,1,0.9,2.1])
     plt.gca().invert_yaxis()
     plt.show()
